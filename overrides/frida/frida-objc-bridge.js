// Primarily generated with:
// npm install frida-objc-bridge@v8.0.5 && echo "import ObjC from 'frida-objc-bridge'; globalThis.ObjC ||= ObjC;" > global-objc.js && npx frida-compile global-objc.js -Sc -B iife -T none -o overrides/frida/frida-objc-bridge.js

(()=>{var F=null,R={exceptions:"propagate"};function H(){if(F!==null)return F;let e={},t=[{module:"libsystem_malloc.dylib",functions:{free:["void",["pointer"]]}},{module:"libobjc.A.dylib",functions:{objc_msgSend:function(r){this.objc_msgSend=r},objc_msgSend_stret:function(r){this.objc_msgSend_stret=r},objc_msgSend_fpret:function(r){this.objc_msgSend_fpret=r},objc_msgSendSuper:function(r){this.objc_msgSendSuper=r},objc_msgSendSuper_stret:function(r){this.objc_msgSendSuper_stret=r},objc_msgSendSuper_fpret:function(r){this.objc_msgSendSuper_fpret=r},objc_getClassList:["int",["pointer","int"]],objc_lookUpClass:["pointer",["pointer"]],objc_allocateClassPair:["pointer",["pointer","pointer","pointer"]],objc_disposeClassPair:["void",["pointer"]],objc_registerClassPair:["void",["pointer"]],class_isMetaClass:["bool",["pointer"]],class_getName:["pointer",["pointer"]],class_getImageName:["pointer",["pointer"]],class_copyProtocolList:["pointer",["pointer","pointer"]],class_copyMethodList:["pointer",["pointer","pointer"]],class_getClassMethod:["pointer",["pointer","pointer"]],class_getInstanceMethod:["pointer",["pointer","pointer"]],class_getSuperclass:["pointer",["pointer"]],class_addProtocol:["bool",["pointer","pointer"]],class_addMethod:["bool",["pointer","pointer","pointer","pointer"]],class_copyIvarList:["pointer",["pointer","pointer"]],objc_getProtocol:["pointer",["pointer"]],objc_copyProtocolList:["pointer",["pointer"]],objc_allocateProtocol:["pointer",["pointer"]],objc_registerProtocol:["void",["pointer"]],protocol_getName:["pointer",["pointer"]],protocol_copyMethodDescriptionList:["pointer",["pointer","bool","bool","pointer"]],protocol_copyPropertyList:["pointer",["pointer","pointer"]],protocol_copyProtocolList:["pointer",["pointer","pointer"]],protocol_addProtocol:["void",["pointer","pointer"]],protocol_addMethodDescription:["void",["pointer","pointer","pointer","bool","bool"]],ivar_getName:["pointer",["pointer"]],ivar_getTypeEncoding:["pointer",["pointer"]],ivar_getOffset:["pointer",["pointer"]],object_isClass:["bool",["pointer"]],object_getClass:["pointer",["pointer"]],object_getClassName:["pointer",["pointer"]],method_getName:["pointer",["pointer"]],method_getTypeEncoding:["pointer",["pointer"]],method_getImplementation:["pointer",["pointer"]],method_setImplementation:["pointer",["pointer","pointer"]],property_getName:["pointer",["pointer"]],property_copyAttributeList:["pointer",["pointer","pointer"]],sel_getName:["pointer",["pointer"]],sel_registerName:["pointer",["pointer"]],class_getInstanceSize:["pointer",["pointer"]]},optionals:{objc_msgSend_stret:"ABI",objc_msgSend_fpret:"ABI",objc_msgSendSuper_stret:"ABI",objc_msgSendSuper_fpret:"ABI",object_isClass:"iOS8"}},{module:"libdispatch.dylib",functions:{dispatch_async_f:["void",["pointer","pointer","pointer"]]},variables:{_dispatch_main_q:function(r){this._dispatch_main_q=r}}}],n=0;return t.forEach(function(r){let o=r.module==="libobjc.A.dylib",a=r.functions||{},l=r.variables||{},u=r.optionals||{};n+=Object.keys(a).length+Object.keys(l).length;let i=(Process.findModuleByName(r.module)?.enumerateExports()??[]).reduce(function(s,c){return s[c.name]=c,s},{});Object.keys(a).forEach(function(s){let c=i[s];if(c!==void 0&&c.type==="function"){let p=a[s];typeof p=="function"?(p.call(e,c.address),o&&p.call(e,c.address)):(e[s]=new NativeFunction(c.address,p[0],p[1],R),o&&(e[s]=e[s])),n--}else u[s]&&n--}),Object.keys(l).forEach(function(s){let c=i[s];c!==void 0&&c.type==="variable"&&(l[s].call(e,c.address),n--)})}),n===0&&(e.objc_msgSend_stret||(e.objc_msgSend_stret=e.objc_msgSend),e.objc_msgSend_fpret||(e.objc_msgSend_fpret=e.objc_msgSend),e.objc_msgSendSuper_stret||(e.objc_msgSendSuper_stret=e.objc_msgSendSuper),e.objc_msgSendSuper_fpret||(e.objc_msgSendSuper_fpret=e.objc_msgSendSuper),F=e),F}var se=`#include <glib.h>
#include <ptrauth.h>

#define KERN_SUCCESS 0
#define MALLOC_PTR_IN_USE_RANGE_TYPE 1
#if defined (HAVE_I386) && GLIB_SIZEOF_VOID_P == 8
# define OBJC_ISA_MASK 0x7ffffffffff8ULL
#elif defined (HAVE_ARM64)
# define OBJC_ISA_MASK 0xffffffff8ULL
#endif

typedef struct _ChooseContext ChooseContext;

typedef struct _malloc_zone_t malloc_zone_t;
typedef struct _malloc_introspection_t malloc_introspection_t;
typedef struct _vm_range_t vm_range_t;

typedef gpointer Class;
typedef int kern_return_t;
typedef guint mach_port_t;
typedef mach_port_t task_t;
typedef guintptr vm_offset_t;
typedef guintptr vm_size_t;
typedef vm_offset_t vm_address_t;

struct _ChooseContext
{
  GHashTable * classes;
  GArray * matches;
};

struct _malloc_zone_t
{
  void * reserved1;
  void * reserved2;
  size_t (* size) (struct _malloc_zone_t * zone, const void * ptr);
  void * (* malloc) (struct _malloc_zone_t * zone, size_t size);
  void * (* calloc) (struct _malloc_zone_t * zone, size_t num_items, size_t size);
  void * (* valloc) (struct _malloc_zone_t * zone, size_t size);
  void (* free) (struct _malloc_zone_t * zone, void * ptr);
  void * (* realloc) (struct _malloc_zone_t * zone, void * ptr, size_t size);
  void (* destroy) (struct _malloc_zone_t * zone);
  const char * zone_name;

  unsigned (* batch_malloc) (struct _malloc_zone_t * zone, size_t size, void ** results, unsigned num_requested);
  void (* batch_free) (struct _malloc_zone_t * zone, void ** to_be_freed, unsigned num_to_be_freed);

  malloc_introspection_t * introspect;
};

typedef kern_return_t (* memory_reader_t) (task_t remote_task, vm_address_t remote_address, vm_size_t size, void ** local_memory);
typedef void (* vm_range_recorder_t) (task_t task, void * user_data, unsigned type, vm_range_t * ranges, unsigned count);
typedef kern_return_t (* enumerator_func) (task_t task, void * user_data, unsigned type_mask, vm_address_t zone_address, memory_reader_t reader,
      vm_range_recorder_t recorder);

struct _malloc_introspection_t
{
  enumerator_func enumerator;
};

struct _vm_range_t
{
  vm_address_t address;
  vm_size_t size;
};

extern int objc_getClassList (Class * buffer, int buffer_count);
extern Class class_getSuperclass (Class cls);
extern size_t class_getInstanceSize (Class cls);
extern kern_return_t malloc_get_all_zones (task_t task, memory_reader_t reader, vm_address_t ** addresses, unsigned * count);

static void collect_subclasses (Class klass, GHashTable * result);
static void collect_matches_in_ranges (task_t task, void * user_data, unsigned type, vm_range_t * ranges, unsigned count);
static kern_return_t read_local_memory (task_t remote_task, vm_address_t remote_address, vm_size_t size, void ** local_memory);

extern mach_port_t selfTask;

gpointer *
choose (Class * klass,
        gboolean consider_subclasses,
        guint * count)
{
  ChooseContext ctx;
  GHashTable * classes;
  vm_address_t * malloc_zone_addresses;
  unsigned malloc_zone_count, i;

  classes = g_hash_table_new_full (NULL, NULL, NULL, NULL);
  ctx.classes = classes;
  ctx.matches = g_array_new (FALSE, FALSE, sizeof (gpointer));
  if (consider_subclasses)
    collect_subclasses (klass, classes);
  else
    g_hash_table_insert (classes, klass, GSIZE_TO_POINTER (class_getInstanceSize (klass)));

  malloc_zone_count = 0;
  malloc_get_all_zones (selfTask, read_local_memory, &malloc_zone_addresses, &malloc_zone_count);

  for (i = 0; i != malloc_zone_count; i++)
  {
    vm_address_t zone_address = malloc_zone_addresses[i];
    malloc_zone_t * zone = (malloc_zone_t *) zone_address;
    enumerator_func enumerator;

    if (zone != NULL && zone->introspect != NULL &&
        (enumerator = (ptrauth_strip (zone->introspect, ptrauth_key_asda))->enumerator) != NULL)
    {
      enumerator = ptrauth_sign_unauthenticated (
          ptrauth_strip (enumerator, ptrauth_key_asia),
          ptrauth_key_asia, 0);

      enumerator (selfTask, &ctx, MALLOC_PTR_IN_USE_RANGE_TYPE, zone_address, read_local_memory,
          collect_matches_in_ranges);
    }
  }

  g_hash_table_unref (classes);

  *count = ctx.matches->len;

  return (gpointer *) g_array_free (ctx.matches, FALSE);
}

void
destroy (gpointer mem)
{
  g_free (mem);
}

static void
collect_subclasses (Class klass,
                    GHashTable * result)
{
  Class * classes;
  int count, i;

  count = objc_getClassList (NULL, 0);
  classes = g_malloc (count * sizeof (gpointer));
  count = objc_getClassList (classes, count);

  for (i = 0; i != count; i++)
  {
    Class candidate = classes[i];
    Class c;

    c = candidate;
    do
    {
      if (c == klass)
      {
        g_hash_table_insert (result, candidate, GSIZE_TO_POINTER (class_getInstanceSize (candidate)));
        break;
      }

      c = class_getSuperclass (c);
    }
    while (c != NULL);
  }

  g_free (classes);
}

static void
collect_matches_in_ranges (task_t task,
                           void * user_data,
                           unsigned type,
                           vm_range_t * ranges,
                           unsigned count)
{
  ChooseContext * ctx = user_data;
  GHashTable * classes = ctx->classes;
  unsigned i;

  for (i = 0; i != count; i++)
  {
    const vm_range_t * range = &ranges[i];
    gconstpointer candidate = GSIZE_TO_POINTER (range->address);
    gconstpointer isa;
    guint instance_size;

    isa = *(gconstpointer *) candidate;
#ifdef OBJC_ISA_MASK
    isa = GSIZE_TO_POINTER (GPOINTER_TO_SIZE (isa) & OBJC_ISA_MASK);
#endif

    instance_size = GPOINTER_TO_UINT (g_hash_table_lookup (classes, isa));
    if (instance_size != 0 && range->size >= instance_size)
    {
      g_array_append_val (ctx->matches, candidate);
    }
  }
}

static kern_return_t
read_local_memory (task_t remote_task,
                   vm_address_t remote_address,
                   vm_size_t size,
                   void ** local_memory)
{
  *local_memory = (void *) remote_address;

  return KERN_SUCCESS;
}
`,{pointerSize:ie}=Process,W=null;function ee(){return W===null&&(W=ae()),W}function ae(){let{objc_getClassList:e,class_getSuperclass:t,class_getInstanceSize:n}=H(),r=Memory.alloc(4);r.writeU32(Module.getGlobalExportByName("mach_task_self_").readU32());let o=new CModule(se,{objc_getClassList:e,class_getSuperclass:t,class_getInstanceSize:n,malloc_get_all_zones:Process.getModuleByName("/usr/lib/system/libsystem_malloc.dylib").getExportByName("malloc_get_all_zones"),selfTask:r}),a=new NativeFunction(o.choose,"pointer",["pointer","bool","pointer"]),l=new NativeFunction(o.destroy,"void",["pointer"]);return{handle:o,choose(u,i){let s=[],c=Memory.alloc(4),p=a(u,i?1:0,c);try{let _=c.readU32();for(let g=0;g!==_;g++)s.push(p.add(g*ie).readPointer())}finally{l(p)}return s}}}function ce(){let pointerSize=Process.pointerSize,api=null,apiError=null,realizedClasses=new Set,classRegistry=new ClassRegistry,protocolRegistry=new ProtocolRegistry,replacedMethods=new Map,scheduledWork=new Map,nextId=1,workCallback=null,NSAutoreleasePool=null,bindings=new Map,readObjectIsa=null,msgSendBySignatureId=new Map,msgSendSuperBySignatureId=new Map,cachedNSString=null,cachedNSStringCtor=null,cachedNSNumber=null,cachedNSNumberCtor=null,singularTypeById=null,modifiers=null;try{tryInitialize()}catch(e){}function tryInitialize(){if(api!==null)return!0;if(apiError!==null)throw apiError;try{api=H()}catch(e){throw apiError=e,e}return api!==null}function dispose(){for(let[e,t]of replacedMethods.entries()){let n=ptr(e),[r,o]=t;api.method_getImplementation(n).equals(o)&&api.method_setImplementation(n,r)}replacedMethods.clear()}Script.bindWeak(this,dispose),Object.defineProperty(this,"available",{enumerable:!0,get(){return tryInitialize()}}),Object.defineProperty(this,"api",{enumerable:!0,get(){return H()}}),Object.defineProperty(this,"classes",{enumerable:!0,value:classRegistry}),Object.defineProperty(this,"protocols",{enumerable:!0,value:protocolRegistry}),Object.defineProperty(this,"Object",{enumerable:!0,value:ObjCObject}),Object.defineProperty(this,"Protocol",{enumerable:!0,value:ObjCProtocol}),Object.defineProperty(this,"Block",{enumerable:!0,value:Block}),Object.defineProperty(this,"mainQueue",{enumerable:!0,get(){return api?._dispatch_main_q??null}}),Object.defineProperty(this,"registerProxy",{enumerable:!0,value:registerProxy}),Object.defineProperty(this,"registerClass",{enumerable:!0,value:registerClass}),Object.defineProperty(this,"registerProtocol",{enumerable:!0,value:registerProtocol}),Object.defineProperty(this,"bind",{enumerable:!0,value:bind}),Object.defineProperty(this,"unbind",{enumerable:!0,value:unbind}),Object.defineProperty(this,"getBoundData",{enumerable:!0,value:getBoundData}),Object.defineProperty(this,"enumerateLoadedClasses",{enumerable:!0,value:enumerateLoadedClasses}),Object.defineProperty(this,"enumerateLoadedClassesSync",{enumerable:!0,value:enumerateLoadedClassesSync}),Object.defineProperty(this,"choose",{enumerable:!0,value:choose}),Object.defineProperty(this,"chooseSync",{enumerable:!0,value(e){let t=[];return choose(e,{onMatch(n){t.push(n)},onComplete(){}}),t}}),this.schedule=function(e,t){let n=ptr(nextId++);scheduledWork.set(n.toString(),t),workCallback===null&&(workCallback=new NativeCallback(performScheduledWorkItem,"void",["pointer"])),Script.pin(),api.dispatch_async_f(e,n,workCallback)};function performScheduledWorkItem(e){let t=e.toString(),n=scheduledWork.get(t);scheduledWork.delete(t),NSAutoreleasePool===null&&(NSAutoreleasePool=classRegistry.NSAutoreleasePool);let r=NSAutoreleasePool.alloc().init(),o=null;try{n()}catch(a){o=a}r.release(),setImmediate(performScheduledWorkCleanup,o)}function performScheduledWorkCleanup(e){if(Script.unpin(),e!==null)throw e}this.implement=function(e,t){return new NativeCallback(t,e.returnType,e.argumentTypes)},this.selector=selector,this.selectorAsString=selectorAsString;function selector(e){return api.sel_registerName(Memory.allocUtf8String(e))}function selectorAsString(e){return api.sel_getName(e).readUtf8String()}let registryBuiltins=new Set(["prototype","constructor","hasOwnProperty","toJSON","toString","valueOf"]);function ClassRegistry(){let e={},t=0,n=new Proxy(this,{has(s,c){return r(c)},get(s,c,p){switch(c){case"prototype":return s.prototype;case"constructor":return s.constructor;case"hasOwnProperty":return r;case"toJSON":return l;case"toString":return u;case"valueOf":return i;default:let _=a(c);return _!==null?_:void 0}},set(s,c,p,_){return!1},ownKeys(s){if(api===null)return[];let c=api.objc_getClassList(NULL,0);if(c!==t){let p=Memory.alloc(c*pointerSize);c=api.objc_getClassList(p,c);for(let _=0;_!==c;_++){let g=p.add(_*pointerSize).readPointer(),y=api.class_getName(g).readUtf8String();e[y]=g}t=c}return Object.keys(e)},getOwnPropertyDescriptor(s,c){return{writable:!1,configurable:!0,enumerable:!0}}});function r(s){return registryBuiltins.has(s)?!0:a(s)!==null}function o(s){let c=a(s);if(c===null)throw new Error("Unable to find class '"+s+"'");return c}function a(s){let c=e[s];if(c===void 0){if(c=api.objc_lookUpClass(Memory.allocUtf8String(s)),c.isNull())return null;e[s]=c,t++}return new ObjCObject(c,void 0,!0)}function l(){return Object.keys(n).reduce(function(s,c){return s[c]=o(c).toJSON(),s},{})}function u(){return"ClassRegistry"}function i(){return"ClassRegistry"}return n}function ProtocolRegistry(){let e={},t=0,n=new Proxy(this,{has(i,s){return r(s)},get(i,s,c){switch(s){case"prototype":return i.prototype;case"constructor":return i.constructor;case"hasOwnProperty":return r;case"toJSON":return a;case"toString":return l;case"valueOf":return u;default:let p=o(s);return p!==null?p:void 0}},set(i,s,c,p){return!1},ownKeys(i){if(api===null)return[];let s=Memory.alloc(pointerSize),c=api.objc_copyProtocolList(s);try{let p=s.readUInt();if(p!==t){e={};for(let _=0;_!==p;_++){let g=c.add(_*pointerSize).readPointer(),y=api.protocol_getName(g).readUtf8String();e[y]=g}t=p}}finally{api.free(c)}return Object.keys(e)},getOwnPropertyDescriptor(i,s){return{writable:!1,configurable:!0,enumerable:!0}}});function r(i){return registryBuiltins.has(i)?!0:o(i)!==null}function o(i){let s=e[i];if(s===void 0){if(s=api.objc_getProtocol(Memory.allocUtf8String(i)),s.isNull())return null;e[i]=s,t++}return new ObjCProtocol(s)}function a(){return Object.keys(n).reduce(function(i,s){return i[s]={handle:e[s]},i},{})}function l(){return"ProtocolRegistry"}function u(){return"ProtocolRegistry"}return n}let objCObjectBuiltins=new Set(["prototype","constructor","handle","hasOwnProperty","toJSON","toString","valueOf","equals","$kind","$super","$superClass","$class","$className","$moduleName","$protocols","$methods","$ownMethods","$ivars"]);function ObjCObject(e,t,n,r){let o=null,a=null,l=null,u=null,i=null,s=null,c=null,p=null,_=null,g=null,y=null,v={},k=null,j=null,P=null;if(e=getHandle(e),n===void 0){let h=api.object_getClass(e),d=h.toString();realizedClasses.has(d)||(api.objc_lookUpClass(api.class_getName(h)),realizedClasses.add(d))}let T=new Proxy(this,{has(h,d){return B(d)},get(h,d,S){switch(d){case"handle":return e;case"prototype":return h.prototype;case"constructor":return h.constructor;case"hasOwnProperty":return B;case"toJSON":return ne;case"toString":case"valueOf":let N=S.description;if(N!==void 0){let b=N.call(S);if(b!==null)return b.UTF8String.bind(b)}return function(){return S.$className};case"equals":return oe;case"$kind":return a===null&&(I()?a=api.class_isMetaClass(e)?"meta-class":"class":a="instance"),a;case"$super":if(l===null){let b=api.class_getSuperclass(U());if(b.isNull())l=[null];else{let w=Memory.alloc(2*pointerSize);w.writePointer(e),w.add(pointerSize).writePointer(b),l=[new ObjCObject(e,void 0,n,w)]}}return l[0];case"$superClass":if(u===null){let b=api.class_getSuperclass(U());b.isNull()?u=[null]:u=[new ObjCObject(b)]}return u[0];case"$class":return i===null&&(i=new ObjCObject(api.object_getClass(e),void 0,!0)),i;case"$className":return s===null&&(r?s=api.class_getName(r.add(pointerSize).readPointer()).readUtf8String():I()?s=api.class_getName(e).readUtf8String():s=api.object_getClassName(e).readUtf8String()),s;case"$moduleName":return c===null&&(c=api.class_getImageName(U()).readUtf8String()),c;case"$protocols":if(p===null){p={};let b=Memory.alloc(pointerSize),w=api.class_copyProtocolList(U(),b);if(!w.isNull())try{let M=b.readUInt();for(let C=0;C!==M;C++){let L=w.add(C*pointerSize).readPointer(),A=new ObjCProtocol(L);p[A.name]=A}}finally{api.free(w)}}return p;case"$methods":if(k===null){let b=r?r.add(pointerSize).readPointer():U(),w=api.object_getClass(b),M=new Set,C=w;do{for(let L of collectMethodNames(C,"+ "))M.add(L);C=api.class_getSuperclass(C)}while(!C.isNull());C=b;do{for(let L of collectMethodNames(C,"- "))M.add(L);C=api.class_getSuperclass(C)}while(!C.isNull());k=Array.from(M)}return k;case"$ownMethods":if(j===null){let b=r?r.add(pointerSize).readPointer():U(),w=api.object_getClass(b),M=collectMethodNames(w,"+ "),C=collectMethodNames(b,"- ");j=M.concat(C)}return j;case"$ivars":return P===null&&(I()?P={}:P=new ObjCIvars(T,U())),P;default:if(typeof d=="symbol")return h[d];if(t){let b=q(d);if(b===null||!b.implemented)return}let O=Q(d);return O===null?void 0:O}},set(h,d,S,N){return!1},ownKeys(h){if(_===null)if(t){let d=[],S=J();Object.keys(S).forEach(function(N){N[0]!=="+"&&N[0]!=="-"&&S[N].implemented&&d.push(N)}),_=d}else{let d={},S={},N=api.object_getClass(e);do{let O=Memory.alloc(pointerSize),b=api.class_copyMethodList(N,O),w=I()?"+ ":"- ";try{let M=O.readUInt();for(let C=0;C!==M;C++){let L=b.add(C*pointerSize).readPointer(),A=api.method_getName(L),z=api.sel_getName(A).readUtf8String();if(S[z]!==void 0)continue;S[z]=z;let E=jsMethodName(z),Z=2,$=E;for(;d[$]!==void 0;)Z++,$=E+Z;d[$]=!0;let Y=w+z;if(v[Y]===void 0){let X={sel:A,handle:L,wrapper:null};v[Y]=X,v[$]=X}}}finally{api.free(b)}N=api.class_getSuperclass(N)}while(!N.isNull());_=Object.keys(d)}return["handle"].concat(_)},getOwnPropertyDescriptor(h,d){return{writable:!1,configurable:!0,enumerable:!0}}});return t&&(y=I()?null:Q("- respondsToSelector:")),T;function B(h){if(objCObjectBuiltins.has(h))return!0;if(t){let d=q(h);return!!(d!==null&&d.implemented)}return x(h)!==null}function U(){return o===null&&(o=I()?e:api.object_getClass(e)),o}function I(){return n===void 0&&(api.object_isClass?n=!!api.object_isClass(e):n=!!api.class_isMetaClass(api.object_getClass(e))),n}function x(h){let d=v[h];if(d!==void 0)return d;let S=re(h),N=S[2];if(d=v[N],d!==void 0)return v[h]=d,d;let O=S[0],b=S[1],w=selector(b),M=I()?"+":"-";if(t){let C=q(N);C!==null&&(d={sel:w,types:C.types,wrapper:null,kind:O})}if(d===void 0){let C=O==="+"?api.class_getClassMethod(U(),w):api.class_getInstanceMethod(U(),w);if(!C.isNull())d={sel:w,handle:C,wrapper:null,kind:O};else{if(I()||O!=="-"||b==="forwardingTargetForSelector:"||b==="methodSignatureForSelector:")return null;let L=T;if("- forwardingTargetForSelector:"in T){let E=T.forwardingTargetForSelector_(w);if(E!==null&&E.$kind==="instance")L=E;else return null}else return null;let A=api.class_getInstanceMethod(api.object_getClass(L.handle),w);if(A.isNull())return null;let z=api.method_getTypeEncoding(A).readUtf8String();if((z===null||z==="")&&(z=D(L,N),z===null&&(z=D(T,N)),z===null))return null;d={sel:w,types:z,wrapper:null,kind:O}}}return v[N]=d,v[h]=d,O===M&&(v[jsMethodName(b)]=d),d}function D(h,d){let N=Object.keys(h.$protocols).map(O=>K({},h.$protocols[O])).reduce((O,b)=>(Object.assign(O,b),O),{})[d];return N===void 0?null:N.types}function K(h,d){return d.methods!==void 0&&Object.assign(h,d.methods),d.protocol!==void 0&&K(h,d.protocol),h}function q(h){let S=J()[h];return S!==void 0?S:null}function J(){if(g===null){let h={},d=collectProtocols(t),S=I()?"+":"-";Object.keys(d).forEach(function(N){let b=d[N].methods;Object.keys(b).forEach(function(w){let M=b[w],C=w.substr(2),L=w[0],A=!1,z=!1,E={types:M.types};Object.defineProperty(E,"implemented",{get(){return A||(M.required?z=!0:z=y!==null&&y.call(T,selector(C)),A=!0),z}}),h[w]=E,L===S&&(h[jsMethodName(C)]=E)})}),g=h}return g}function Q(h){let d=x(h);if(d===null)return null;let S=d.wrapper;return S===null&&(S=makeMethodInvocationWrapper(d,T,r,R),d.wrapper=S),S}function re(h){let d=/([+\-])\s(\S+)/.exec(h),S,N;d===null?(N=I()?"+":"-",S=objcMethodName(h)):(N=d[1],S=d[2]);let O=[N,S].join(" ");return[N,S,O]}function ne(){return{handle:e.toString()}}function oe(h){return e.equals(getHandle(h))}}function getReplacementMethodImplementation(e){let t=replacedMethods.get(e.toString());if(t===void 0)return null;let[,n]=t;return n}function replaceMethodImplementation(e,t){let n=e.toString(),r,o=replacedMethods.get(n);o!==void 0?[r]=o:r=api.method_getImplementation(e),t.equals(r)?replacedMethods.delete(n):replacedMethods.set(n,[r,t]),api.method_setImplementation(e,t)}function collectMethodNames(e,t){let n=[],r=Memory.alloc(pointerSize),o=api.class_copyMethodList(e,r);try{let a=r.readUInt();for(let l=0;l!==a;l++){let u=o.add(l*pointerSize).readPointer(),i=api.method_getName(u),s=api.sel_getName(i).readUtf8String();n.push(t+s)}}finally{api.free(o)}return n}function ObjCProtocol(e){let t=null,n=null,r=null,o=null;Object.defineProperty(this,"handle",{value:e,enumerable:!0}),Object.defineProperty(this,"name",{get(){return t===null&&(t=api.protocol_getName(e).readUtf8String()),t},enumerable:!0}),Object.defineProperty(this,"protocols",{get(){if(n===null){n={};let l=Memory.alloc(pointerSize),u=api.protocol_copyProtocolList(e,l);if(!u.isNull())try{let i=l.readUInt();for(let s=0;s!==i;s++){let c=u.add(s*pointerSize).readPointer(),p=new ObjCProtocol(c);n[p.name]=p}}finally{api.free(u)}}return n},enumerable:!0}),Object.defineProperty(this,"properties",{get(){if(r===null){r={};let l=Memory.alloc(pointerSize),u=api.protocol_copyPropertyList(e,l);if(!u.isNull())try{let i=l.readUInt();for(let s=0;s!==i;s++){let c=u.add(s*pointerSize).readPointer(),p=api.property_getName(c).readUtf8String(),_={},g=api.property_copyAttributeList(c,l);if(!g.isNull())try{let y=l.readUInt();for(let v=0;v!==y;v++){let k=g.add(v*(2*pointerSize)),j=k.readPointer().readUtf8String(),P=k.add(pointerSize).readPointer().readUtf8String();_[j]=P}}finally{api.free(g)}r[p]=_}}finally{api.free(u)}}return r},enumerable:!0}),Object.defineProperty(this,"methods",{get(){if(o===null){o={};let l=Memory.alloc(pointerSize);a(o,l,{required:!0,instance:!1}),a(o,l,{required:!1,instance:!1}),a(o,l,{required:!0,instance:!0}),a(o,l,{required:!1,instance:!0})}return o},enumerable:!0});function a(l,u,i){let s=api.protocol_copyMethodDescriptionList(e,i.required?1:0,i.instance?1:0,u);if(!s.isNull())try{let c=u.readUInt();for(let p=0;p!==c;p++){let _=s.add(p*(2*pointerSize)),g=(i.instance?"- ":"+ ")+selectorAsString(_.readPointer()),y=_.add(pointerSize).readPointer().readUtf8String();l[g]={required:i.required,types:y}}}finally{api.free(s)}}}let objCIvarsBuiltins=new Set(["prototype","constructor","hasOwnProperty","toJSON","toString","valueOf"]);function ObjCIvars(e,t){let n={},r=null,o=[],a=t;do o.unshift(a),a=api.class_getSuperclass(a);while(!a.isNull());let l=Memory.alloc(pointerSize);o.forEach(g=>{let y=api.class_copyIvarList(g,l);try{let v=l.readUInt();for(let k=0;k!==v;k++){let j=y.add(k*pointerSize).readPointer(),P=api.ivar_getName(j).readUtf8String();n[P]=[j,null]}}finally{api.free(y)}});let u=new Proxy(this,{has(g,y){return s(y)},get(g,y,v){switch(y){case"prototype":return g.prototype;case"constructor":return g.constructor;case"hasOwnProperty":return s;case"toJSON":return c;case"toString":return p;case"valueOf":return _;default:let k=i(y);return k===null?void 0:k.get()}},set(g,y,v,k){let j=i(y);if(j===null)throw new Error("Unknown ivar");return j.set(v),!0},ownKeys(g){return r===null&&(r=Object.keys(n)),r},getOwnPropertyDescriptor(g,y){return{writable:!0,configurable:!0,enumerable:!0}}});return u;function i(g){let y=n[g];if(y===void 0)return null;let v=y[1];if(v===null){let k=y[0],j=api.ivar_getOffset(k).toInt32(),P=e.handle.add(j),T=parseType(api.ivar_getTypeEncoding(k).readUtf8String()),B=T.fromNative||identityTransform,U=T.toNative||identityTransform,I,x;g==="isa"?(I=readObjectIsa,x=function(){throw new Error("Unable to set the isa instance variable")}):(I=T.read,x=T.write),v={get(){return B.call(e,I(P))},set(D){x(P,U.call(e,D))}},y[1]=v}return v}function s(g){return objCIvarsBuiltins.has(g)?!0:n.hasOwnProperty(g)}function c(){return Object.keys(u).reduce(function(g,y){return g[y]=u[y],g},{})}function p(){return"ObjCIvars"}function _(){return"ObjCIvars"}}let blockDescriptorAllocSize,blockDescriptorDeclaredSize,blockDescriptorOffsets,blockSize,blockOffsets;pointerSize===4?(blockDescriptorAllocSize=16,blockDescriptorDeclaredSize=20,blockDescriptorOffsets={reserved:0,size:4,rest:8},blockSize=20,blockOffsets={isa:0,flags:4,reserved:8,invoke:12,descriptor:16}):(blockDescriptorAllocSize=32,blockDescriptorDeclaredSize=32,blockDescriptorOffsets={reserved:0,size:8,rest:16},blockSize=32,blockOffsets={isa:0,flags:8,reserved:12,invoke:16,descriptor:24});let BLOCK_HAS_COPY_DISPOSE=1<<25,BLOCK_HAS_CTOR=1<<26,BLOCK_IS_GLOBAL=1<<28,BLOCK_HAS_STRET=1<<29,BLOCK_HAS_SIGNATURE=1<<30;function Block(e,t=R){if(this._options=t,e instanceof NativePointer){let n=e.add(blockOffsets.descriptor).readPointer();this.handle=e;let r=e.add(blockOffsets.flags).readU32();if((r&BLOCK_HAS_SIGNATURE)!==0){let o=(r&BLOCK_HAS_COPY_DISPOSE)!==0?2:0;this.types=n.add(blockDescriptorOffsets.rest+o*pointerSize).readPointer().readCString(),this._signature=parseSignature(this.types)}else this._signature=null}else{this.declare(e);let n=Memory.alloc(blockDescriptorAllocSize+blockSize),r=n.add(blockDescriptorAllocSize),o=Memory.allocUtf8String(this.types);n.add(blockDescriptorOffsets.reserved).writeULong(0),n.add(blockDescriptorOffsets.size).writeULong(blockDescriptorDeclaredSize),n.add(blockDescriptorOffsets.rest).writePointer(o),r.add(blockOffsets.isa).writePointer(classRegistry.__NSGlobalBlock__),r.add(blockOffsets.flags).writeU32(BLOCK_HAS_SIGNATURE|BLOCK_IS_GLOBAL),r.add(blockOffsets.reserved).writeU32(0),r.add(blockOffsets.descriptor).writePointer(n),this.handle=r,this._storage=[n,o],this.implementation=e.implementation}}Object.defineProperties(Block.prototype,{implementation:{enumerable:!0,get(){let e=this.handle.add(blockOffsets.invoke).readPointer().strip(),t=this._getSignature();return makeBlockInvocationWrapper(this,t,new NativeFunction(e.sign(),t.retType.type,t.argTypes.map(function(n){return n.type}),this._options))},set(e){let t=this._getSignature(),n=new NativeCallback(makeBlockImplementationWrapper(this,t,e),t.retType.type,t.argTypes.map(function(l){return l.type}));this._callback=n;let r=this.handle.add(blockOffsets.invoke),o=Memory.queryProtection(r),a=o.includes("w");a||Memory.protect(r,Process.pointerSize,"rw-"),r.writePointer(n.strip().sign("ia",r)),a||Memory.protect(r,Process.pointerSize,o)}},declare:{value(e){let t=e.types;t===void 0&&(t=unparseSignature(e.retType,["block"].concat(e.argTypes))),this.types=t,this._signature=parseSignature(t)}},_getSignature:{value(){let e=this._signature;if(e===null)throw new Error("block is missing signature; call declare()");return e}}});function collectProtocols(e,t){t=t||{},t[e.name]=e;let n=e.protocols;return Object.keys(n).forEach(function(r){collectProtocols(n[r],t)}),t}function registerProxy(e){let t=e.protocols||[],n=e.methods||{},r=e.events||{},o=new Set(Object.keys(n).filter(i=>/([+\-])\s(\S+)/.exec(i)!==null).map(i=>i.split(" ")[1])),a={"- dealloc":function(){let i=this.data.target;"- release"in i&&i.release(),unbind(this.self),this.super.dealloc();let s=this.data.events.dealloc;s!==void 0&&s.call(this)},"- respondsToSelector:":function(i){let s=selectorAsString(i);return o.has(s)?!0:this.data.target.respondsToSelector_(i)},"- forwardingTargetForSelector:":function(i){let s=this.data.events.forward;return s!==void 0&&s.call(this,selectorAsString(i)),this.data.target},"- methodSignatureForSelector:":function(i){return this.data.target.methodSignatureForSelector_(i)},"- forwardInvocation:":function(i){i.invokeWithTarget_(this.data.target)}};for(var l in n)if(n.hasOwnProperty(l)){if(a.hasOwnProperty(l))throw new Error("The '"+l+"' method is reserved");a[l]=n[l]}let u=registerClass({name:e.name,super:classRegistry.NSProxy,protocols:t,methods:a});return function(i,s){i=i instanceof NativePointer?new ObjCObject(i):i,s=s||{};let c=u.alloc().autorelease(),p=getBoundData(c);p.target="- retain"in i?i.retain():i,p.events=r;for(var _ in s)if(s.hasOwnProperty(_)){if(p.hasOwnProperty(_))throw new Error("The '"+_+"' property is reserved");p[_]=s[_]}this.handle=c.handle}}function registerClass(e){let t=e.name;t===void 0&&(t=makeClassName());let n=e.super!==void 0?e.super:classRegistry.NSObject,r=e.protocols||[],o=e.methods||{},a=[],l=api.objc_allocateClassPair(n!==null?n.handle:NULL,Memory.allocUtf8String(t),ptr("0"));if(l.isNull())throw new Error("Unable to register already registered class '"+t+"'");let u=api.object_getClass(l);try{r.forEach(function(i){api.class_addProtocol(l,i.handle)}),Object.keys(o).forEach(function(i){let s=/([+\-])\s(\S+)/.exec(i);if(s===null)throw new Error("Invalid method name");let c=s[1],p=s[2],_,g=o[i];if(typeof g=="function"){let P=null;if(i in n)P=n[i].types;else for(let T of r){let B=T.methods[i];if(B!==void 0){P=B.types;break}}if(P===null)throw new Error("Unable to find '"+i+"' in super-class or any of its protocols");_={types:P,implementation:g}}else _=g;let y=c==="+"?u:l,v=_.types;v===void 0&&(v=unparseSignature(_.retType,[c==="+"?"class":"object","selector"].concat(_.argTypes)));let k=parseSignature(v),j=new NativeCallback(makeMethodImplementationWrapper(k,_.implementation),k.retType.type,k.argTypes.map(function(P){return P.type}));a.push(j),api.class_addMethod(y,selector(p),j,Memory.allocUtf8String(v))})}catch(i){throw api.objc_disposeClassPair(l),i}return api.objc_registerClassPair(l),l._methodCallbacks=a,Script.bindWeak(l,makeClassDestructor(ptr(l))),new ObjCObject(l)}function makeClassDestructor(e){return function(){api.objc_disposeClassPair(e)}}function registerProtocol(e){let t=e.name;t===void 0&&(t=makeProtocolName());let n=e.protocols||[],r=e.methods||{};n.forEach(function(l){if(!(l instanceof ObjCProtocol))throw new Error("Expected protocol")});let o=Object.keys(r).map(function(l){let u=r[l],i=/([+\-])\s(\S+)/.exec(l);if(i===null)throw new Error("Invalid method name");let s=i[1],c=i[2],p=u.types;return p===void 0&&(p=unparseSignature(u.retType,[s==="+"?"class":"object","selector"].concat(u.argTypes))),{kind:s,name:c,types:p,optional:u.optional}}),a=api.objc_allocateProtocol(Memory.allocUtf8String(t));if(a.isNull())throw new Error("Unable to register already registered protocol '"+t+"'");return n.forEach(function(l){api.protocol_addProtocol(a,l.handle)}),o.forEach(function(l){let u=l.optional?0:1,i=l.kind==="-"?1:0;api.protocol_addMethodDescription(a,selector(l.name),Memory.allocUtf8String(l.types),u,i)}),api.objc_registerProtocol(a),new ObjCProtocol(a)}function getHandle(e){if(e instanceof NativePointer)return e;if(typeof e=="object"&&e.hasOwnProperty("handle"))return e.handle;throw new Error("Expected NativePointer or ObjC.Object instance")}function bind(e,t){let n=getHandle(e),r=e instanceof ObjCObject?e:new ObjCObject(n);bindings.set(n.toString(),{self:r,super:r.$super,data:t})}function unbind(e){let t=getHandle(e);bindings.delete(t.toString())}function getBoundData(e){return getBinding(e).data}function getBinding(e){let t=getHandle(e),n=t.toString(),r=bindings.get(n);if(r===void 0){let o=e instanceof ObjCObject?e:new ObjCObject(t);r={self:o,super:o.$super,data:{}},bindings.set(n,r)}return r}function enumerateLoadedClasses(...e){let t=new ModuleMap,n=!1,r,o;e.length===1?r=e[0]:(r=e[1],o=e[0].ownedBy),o===void 0&&(o=t,n=!0);let a=api.class_getName,l=r.onMatch.bind(r),u=(pointerSize===8?8:11)*pointerSize,i=api.objc_getClassList(NULL,0),s=Memory.alloc(i*pointerSize);api.objc_getClassList(s,i);for(let c=0;c!==i;c++){let p=s.add(c*pointerSize).readPointer(),_=a(p),g=null,y=o.findPath(_);if(y===null&&(n||t.findPath(_)===null)&&(g=_.readCString(),g.indexOf(".")!==-1)){let j=p.add(u).readPointer();y=o.findPath(j)}y!==null&&(g===null&&(g=_.readUtf8String()),l(g,y))}r.onComplete()}function enumerateLoadedClassesSync(e={}){let t={};return enumerateLoadedClasses(e,{onMatch(n,r){let o=t[r];o===void 0&&(o=[],t[r]=o),o.push(n)},onComplete(){}}),t}function choose(e,t){let n=e,r=!0;if(!(e instanceof ObjCObject)&&typeof e=="object"&&(n=e.class,e.hasOwnProperty("subclasses")&&(r=e.subclasses)),!(n instanceof ObjCObject&&(n.$kind==="class"||n.$kind==="meta-class")))throw new Error("Expected an ObjC.Object for a class or meta-class");let o=ee().choose(n,r).map(a=>new ObjCObject(a));for(let a of o)if(t.onMatch(a)==="stop")break;t.onComplete()}function makeMethodInvocationWrapper(method,owner,superSpecifier,invocationOptions){let sel=method.sel,handle=method.handle,types;handle===void 0?(handle=null,types=method.types):types=api.method_getTypeEncoding(handle).readUtf8String();let signature=parseSignature(types),retType=signature.retType,argTypes=signature.argTypes.slice(2),objc_msgSend=superSpecifier?getMsgSendSuperImpl(signature,invocationOptions):getMsgSendImpl(signature,invocationOptions),argVariableNames=argTypes.map(function(e,t){return"a"+(t+1)}),callArgs=[superSpecifier?"superSpecifier":"this","sel"].concat(argTypes.map(function(e,t){return e.toNative?"argTypes["+t+"].toNative.call(this, "+argVariableNames[t]+")":argVariableNames[t]})),returnCaptureLeft,returnCaptureRight;retType.type==="void"?(returnCaptureLeft="",returnCaptureRight=""):retType.fromNative?(returnCaptureLeft="return retType.fromNative.call(this, ",returnCaptureRight=")"):(returnCaptureLeft="return ",returnCaptureRight="");let m=eval("var m = function ("+argVariableNames.join(", ")+") { "+returnCaptureLeft+"objc_msgSend("+callArgs.join(", ")+")"+returnCaptureRight+"; }; m;");Object.defineProperty(m,"handle",{enumerable:!0,get:getMethodHandle}),m.selector=sel,Object.defineProperty(m,"implementation",{enumerable:!0,get(){let e=getMethodHandle(),t=new NativeFunction(api.method_getImplementation(e),m.returnType,m.argumentTypes,invocationOptions),n=getReplacementMethodImplementation(e);return n!==null&&(t._callback=n),t},set(e){replaceMethodImplementation(getMethodHandle(),e)}}),m.returnType=retType.type,m.argumentTypes=signature.argTypes.map(e=>e.type),m.types=types,Object.defineProperty(m,"symbol",{enumerable:!0,get(){return`${method.kind}[${owner.$className} ${selectorAsString(sel)}]`}}),m.clone=function(e){return makeMethodInvocationWrapper(method,owner,superSpecifier,e)};function getMethodHandle(){if(handle===null){if(owner.$kind==="instance"){let e=owner;do if("- forwardingTargetForSelector:"in e){let t=e.forwardingTargetForSelector_(sel);if(t===null||t.$kind!=="instance")break;let n=api.class_getInstanceMethod(t.$class.handle,sel);n.isNull()?e=t:handle=n}else break;while(handle===null)}if(handle===null)throw new Error("Unable to find method handle of proxied function")}return handle}return m}function makeMethodImplementationWrapper(signature,implementation){let retType=signature.retType,argTypes=signature.argTypes,argVariableNames=argTypes.map(function(e,t){return t===0?"handle":t===1?"sel":"a"+(t-1)}),callArgs=argTypes.slice(2).map(function(e,t){let n=argVariableNames[2+t];return e.fromNative?"argTypes["+(2+t)+"].fromNative.call(self, "+n+")":n}),returnCaptureLeft,returnCaptureRight;retType.type==="void"?(returnCaptureLeft="",returnCaptureRight=""):retType.toNative?(returnCaptureLeft="return retType.toNative.call(self, ",returnCaptureRight=")"):(returnCaptureLeft="return ",returnCaptureRight="");let m=eval("var m = function ("+argVariableNames.join(", ")+") { var binding = getBinding(handle);var self = binding.self;"+returnCaptureLeft+"implementation.call(binding"+(callArgs.length>0?", ":"")+callArgs.join(", ")+")"+returnCaptureRight+"; }; m;");return m}function makeBlockInvocationWrapper(block,signature,implementation){let retType=signature.retType,argTypes=signature.argTypes.slice(1),argVariableNames=argTypes.map(function(e,t){return"a"+(t+1)}),callArgs=argTypes.map(function(e,t){return e.toNative?"argTypes["+t+"].toNative.call(this, "+argVariableNames[t]+")":argVariableNames[t]}),returnCaptureLeft,returnCaptureRight;retType.type==="void"?(returnCaptureLeft="",returnCaptureRight=""):retType.fromNative?(returnCaptureLeft="return retType.fromNative.call(this, ",returnCaptureRight=")"):(returnCaptureLeft="return ",returnCaptureRight="");let f=eval("var f = function ("+argVariableNames.join(", ")+") { "+returnCaptureLeft+"implementation(this"+(callArgs.length>0?", ":"")+callArgs.join(", ")+")"+returnCaptureRight+"; }; f;");return f.bind(block)}function makeBlockImplementationWrapper(block,signature,implementation){let retType=signature.retType,argTypes=signature.argTypes,argVariableNames=argTypes.map(function(e,t){return t===0?"handle":"a"+t}),callArgs=argTypes.slice(1).map(function(e,t){let n=argVariableNames[1+t];return e.fromNative?"argTypes["+(1+t)+"].fromNative.call(this, "+n+")":n}),returnCaptureLeft,returnCaptureRight;retType.type==="void"?(returnCaptureLeft="",returnCaptureRight=""):retType.toNative?(returnCaptureLeft="return retType.toNative.call(this, ",returnCaptureRight=")"):(returnCaptureLeft="return ",returnCaptureRight="");let f=eval("var f = function ("+argVariableNames.join(", ")+") { if (!this.handle.equals(handle))this.handle = handle;"+returnCaptureLeft+"implementation.call(block"+(callArgs.length>0?", ":"")+callArgs.join(", ")+")"+returnCaptureRight+"; }; f;");return f.bind(block)}function rawFridaType(e){return e==="object"?"pointer":e}function makeClassName(){for(let e=1;;e++){let t="FridaAnonymousClass"+e;if(!(t in classRegistry))return t}}function makeProtocolName(){for(let e=1;;e++){let t="FridaAnonymousProtocol"+e;if(!(t in protocolRegistry))return t}}function objcMethodName(e){return e.replace(/_/g,":")}function jsMethodName(e){let t=e.replace(/:/g,"_");return objCObjectBuiltins.has(t)&&(t+="2"),t}let isaMasks={x64:"0x7ffffffffff8",arm64:"0xffffffff8"},rawMask=isaMasks[Process.arch];if(rawMask!==void 0){let e=ptr(rawMask);readObjectIsa=function(t){return t.readPointer().and(e)}}else readObjectIsa=function(e){return e.readPointer()};function getMsgSendImpl(e,t){return resolveMsgSendImpl(msgSendBySignatureId,e,t,!1)}function getMsgSendSuperImpl(e,t){return resolveMsgSendImpl(msgSendSuperBySignatureId,e,t,!0)}function resolveMsgSendImpl(e,t,n,r){if(n!==R)return makeMsgSendImpl(t,n,r);let{id:o}=t,a=e.get(o);return a===void 0&&(a=makeMsgSendImpl(t,n,r),e.set(o,a)),a}function makeMsgSendImpl(e,t,n){let r=e.retType.type,o=e.argTypes.map(function(i){return i.type}),a=["objc_msgSend"];n&&a.push("Super"),r instanceof Array&&!typeFitsInRegisters(r)?a.push("_stret"):(r==="float"||r==="double")&&a.push("_fpret");let u=a.join("");return new NativeFunction(api[u],r,o,t)}function typeFitsInRegisters(e){return Process.arch!=="x64"?!1:sizeOfTypeOnX64(e)<=16}function sizeOfTypeOnX64(e){if(e instanceof Array)return e.reduce((t,n)=>t+sizeOfTypeOnX64(n),0);switch(e){case"bool":case"char":case"uchar":return 1;case"int16":case"uint16":return 2;case"int":case"int32":case"uint":case"uint32":case"float":return 4;default:return 8}}function unparseSignature(e,t){let n=typeIdFromAlias(e),r=t.map(typeIdFromAlias),o=r.map(u=>singularTypeById[u].size),a=o.reduce((u,i)=>u+i,0),l=0;return n+a+r.map((u,i)=>{let s=u+l;return l+=o[i],s}).join("")}function parseSignature(e){let t=[e,0];parseQualifiers(t);let n=readType(t);readNumber(t);let r=[],o=JSON.stringify(n.type);for(;dataAvailable(t);){parseQualifiers(t);let a=readType(t);readNumber(t),r.push(a),o+=JSON.stringify(a.type)}return{id:o,retType:n,argTypes:r}}function parseType(e){return readType([e,0])}function readType(e){let t=readChar(e);if(t==="@"){let r=peekChar(e);r==="?"?(t+=r,skipChar(e),peekChar(e)==="<"&&skipExtendedBlock(e)):r==='"'&&(skipChar(e),readUntil('"',e))}else if(t==="^"){let r=peekChar(e);r==="@"&&(t+=r,skipChar(e))}let n=singularTypeById[t];if(n!==void 0)return n;if(t==="["){let r=readNumber(e),o=readType(e);return skipChar(e),arrayType(r,o)}else if(t==="{"){if(!tokenExistsAhead("=","}",e))return readUntil("}",e),structType([]);readUntil("=",e);let r=[],o;for(;(o=peekChar(e))!=="}";)o==='"'&&(skipChar(e),readUntil('"',e)),r.push(readType(e));return skipChar(e),structType(r)}else if(t==="("){readUntil("=",e);let r=[];for(;peekChar(e)!==")";)r.push(readType(e));return skipChar(e),unionType(r)}else{if(t==="b")return readNumber(e),singularTypeById.i;if(t==="^")return readType(e),singularTypeById["?"];if(modifiers.has(t))return readType(e);throw new Error("Unable to handle type "+t)}}function skipExtendedBlock(e){let t;for(skipChar(e);(t=peekChar(e))!==">";)peekChar(e)==="<"?skipExtendedBlock(e):(skipChar(e),t==='"'&&readUntil('"',e));skipChar(e)}function readNumber(e){let t="";for(;dataAvailable(e);){let n=peekChar(e),r=n.charCodeAt(0);if(r>=48&&r<=57)t+=n,skipChar(e);else break}return parseInt(t)}function readUntil(e,t){let n=t[0],r=t[1],o=n.indexOf(e,r);if(o===-1)throw new Error("Expected token '"+e+"' not found");let a=n.substring(r,o);return t[1]=o+1,a}function readChar(e){return e[0][e[1]++]}function peekChar(e){return e[0][e[1]]}function tokenExistsAhead(e,t,n){let[r,o]=n,a=r.indexOf(e,o);if(a===-1)return!1;let l=r.indexOf(t,o);if(l===-1)throw new Error("Expected to find terminator: "+t);return a<l}function skipChar(e){e[1]++}function dataAvailable(e){return e[1]!==e[0].length}let qualifierById={r:"const",n:"in",N:"inout",o:"out",O:"bycopy",R:"byref",V:"oneway"};function parseQualifiers(e){let t=[];for(;;){let n=qualifierById[peekChar(e)];if(n===void 0)break;t.push(n),skipChar(e)}return t}let idByAlias={char:"c",int:"i",int16:"s",int32:"i",int64:"q",uchar:"C",uint:"I",uint16:"S",uint32:"I",uint64:"Q",float:"f",double:"d",bool:"B",void:"v",string:"*",object:"@",block:"@?",class:"#",selector:":",pointer:"^v"};function typeIdFromAlias(e){if(typeof e=="object"&&e!==null)return`@"${e.type}"`;let t=idByAlias[e];if(t===void 0)throw new Error("No known encoding for type "+e);return t}let fromNativeId=function(e){return e.isNull()?null:e.toString(16)===this.handle.toString(16)?this:new ObjCObject(e)},toNativeId=function(e){if(e===null)return NULL;let t=typeof e;return t==="string"?(cachedNSStringCtor===null&&(cachedNSString=classRegistry.NSString,cachedNSStringCtor=cachedNSString.stringWithUTF8String_),cachedNSStringCtor.call(cachedNSString,Memory.allocUtf8String(e))):t==="number"?(cachedNSNumberCtor===null&&(cachedNSNumber=classRegistry.NSNumber,cachedNSNumberCtor=cachedNSNumber.numberWithDouble_),cachedNSNumberCtor.call(cachedNSNumber,e)):e},fromNativeBlock=function(e){return e.isNull()?null:e.toString(16)===this.handle.toString(16)?this:new Block(e)},toNativeBlock=function(e){return e!==null?e:NULL},toNativeObjectArray=function(e){if(e instanceof Array){let t=e.length,n=Memory.alloc(t*pointerSize);for(let r=0;r!==t;r++)n.add(r*pointerSize).writePointer(toNativeId(e[r]));return n}return e};function arrayType(e,t){return{type:"pointer",read(n){let r=[],o=t.size;for(let a=0;a!==e;a++)r.push(t.read(n.add(a*o)));return r},write(n,r){let o=t.size;r.forEach((a,l)=>{t.write(n.add(l*o),a)})}}}function structType(e){let t,n;if(e.some(function(a){return!!a.fromNative})){let a=e.map(function(l){return l.fromNative?l.fromNative:identityTransform});t=function(l){return l.map(function(u,i){return a[i].call(this,u)})}}else t=identityTransform;if(e.some(function(a){return!!a.toNative})){let a=e.map(function(l){return l.toNative?l.toNative:identityTransform});n=function(l){return l.map(function(u,i){return a[i].call(this,u)})}}else n=identityTransform;let[r,o]=e.reduce(function(a,l){let[u,i]=a,{size:s}=l,c=align(u,s);return i.push(c),[c+s,i]},[0,[]]);return{type:e.map(a=>a.type),size:r,read(a){return e.map((l,u)=>l.read(a.add(o[u])))},write(a,l){l.forEach((u,i)=>{e[i].write(a.add(o[i]),u)})},fromNative:t,toNative:n}}function unionType(e){let t=e.reduce(function(o,a){return a.size>o.size?a:o},e[0]),n,r;if(t.fromNative){let o=t.fromNative;n=function(a){return o.call(this,a[0])}}else n=function(o){return o[0]};if(t.toNative){let o=t.toNative;r=function(a){return[o.call(this,a)]}}else r=function(o){return[o]};return{type:[t.type],size:t.size,read:t.read,write:t.write,fromNative:n,toNative:r}}let longBits=pointerSize==8&&Process.platform!=="windows"?64:32;modifiers=new Set(["j","A","r","n","N","o","O","R","V","+"]),singularTypeById={c:{type:"char",size:1,read:e=>e.readS8(),write:(e,t)=>{e.writeS8(t)},toNative(e){return typeof e=="boolean"?e?1:0:e}},i:{type:"int",size:4,read:e=>e.readInt(),write:(e,t)=>{e.writeInt(t)}},s:{type:"int16",size:2,read:e=>e.readS16(),write:(e,t)=>{e.writeS16(t)}},l:{type:"int32",size:4,read:e=>e.readS32(),write:(e,t)=>{e.writeS32(t)}},q:{type:"int64",size:8,read:e=>e.readS64(),write:(e,t)=>{e.writeS64(t)}},C:{type:"uchar",size:1,read:e=>e.readU8(),write:(e,t)=>{e.writeU8(t)}},I:{type:"uint",size:4,read:e=>e.readUInt(),write:(e,t)=>{e.writeUInt(t)}},S:{type:"uint16",size:2,read:e=>e.readU16(),write:(e,t)=>{e.writeU16(t)}},L:{type:"uint"+longBits,size:longBits/8,read:e=>e.readULong(),write:(e,t)=>{e.writeULong(t)}},Q:{type:"uint64",size:8,read:e=>e.readU64(),write:(e,t)=>{e.writeU64(t)}},f:{type:"float",size:4,read:e=>e.readFloat(),write:(e,t)=>{e.writeFloat(t)}},d:{type:"double",size:8,read:e=>e.readDouble(),write:(e,t)=>{e.writeDouble(t)}},B:{type:"bool",size:1,read:e=>e.readU8(),write:(e,t)=>{e.writeU8(t)},fromNative(e){return!!e},toNative(e){return e?1:0}},v:{type:"void",size:0},"*":{type:"pointer",size:pointerSize,read:e=>e.readPointer(),write:(e,t)=>{e.writePointer(t)},fromNative(e){return e.readUtf8String()}},"@":{type:"pointer",size:pointerSize,read:e=>e.readPointer(),write:(e,t)=>{e.writePointer(t)},fromNative:fromNativeId,toNative:toNativeId},"@?":{type:"pointer",size:pointerSize,read:e=>e.readPointer(),write:(e,t)=>{e.writePointer(t)},fromNative:fromNativeBlock,toNative:toNativeBlock},"^@":{type:"pointer",size:pointerSize,read:e=>e.readPointer(),write:(e,t)=>{e.writePointer(t)},toNative:toNativeObjectArray},"^v":{type:"pointer",size:pointerSize,read:e=>e.readPointer(),write:(e,t)=>{e.writePointer(t)}},"#":{type:"pointer",size:pointerSize,read:e=>e.readPointer(),write:(e,t)=>{e.writePointer(t)},fromNative:fromNativeId,toNative:toNativeId},":":{type:"pointer",size:pointerSize,read:e=>e.readPointer(),write:(e,t)=>{e.writePointer(t)}},"?":{type:"pointer",size:pointerSize,read:e=>e.readPointer(),write:(e,t)=>{e.writePointer(t)}}};function identityTransform(e){return e}function align(e,t){let n=e%t;return n===0?e:e+(t-n)}}var ue=new ce,te=ue;globalThis.ObjC||=te;})();
